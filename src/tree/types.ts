/**
 * Tree of IDs — Types
 * ----------------------------------------------------------------------------
 * The Tree of IDs is an LLM-navigable execution tree where each node has:
 *   - ID (from FlowChart builder — stable, predictable)
 *   - Description (from Builder — what the stage is designed to do)
 *   - Narrative (from NarrativeGenerator — what actually happened)
 *   - Data (from Recorders — reads, writes, metrics, errors)
 *
 * An LLM gets the SUMMARY first (IDs + short descriptions), then calls
 * drillDown(id) for full details. This is lazy-loading for LLM context
 * windows — don't dump everything at once.
 *
 * VISION: Build an LLM-friendly system for both:
 *   - Customers: "What happened to my request?" → Navigate tree → find answer
 *   - Providers: "Why did this fail?" → Navigate tree → find root cause
 *
 * @module tree/types
 */

// ============================================================================
// Tree Node — A single node in the execution tree
// ============================================================================

/**
 * A node in the execution tree.
 *
 * Each node corresponds to a stage in the FlowChart. The tree structure
 * mirrors the execution structure (linear, fork, decider, subflow).
 */
export interface TreeNode {
  /** Stable ID from the FlowChart builder (e.g., 'validate-input', 'llm-call') */
  id: string;
  /** Human-readable stage name */
  name: string;
  /** Display name (if different from name) */
  displayName?: string;
  /**
   * Builder description — what this stage is DESIGNED to do.
   * Set by the developer when building the FlowChart.
   */
  builderDescription?: string;
  /**
   * Narrative description — what ACTUALLY HAPPENED during execution.
   * Generated by NarrativeGenerator at runtime.
   */
  narrativeSummary?: string;
  /** Combined description: builder description + narrative summary */
  description: string;
  /** Depth in the tree (0 = root) */
  depth: number;
  /** Node type (how it was traversed) */
  nodeType: TreeNodeType;
  /** Children nodes (for forks, subflows, parallel execution) */
  children: TreeNode[];
  /** Whether this node has detailed data available via drillDown() */
  hasDetails: boolean;
  /** Execution status */
  status: 'success' | 'error' | 'skipped' | 'pending';
  /** Duration in ms (if available) */
  durationMs?: number;
  /** Error message (if status is 'error') */
  errorMessage?: string;
}

/**
 * How the node was traversed in the FlowChart.
 */
export type TreeNodeType =
  | 'stage'       // Regular linear stage
  | 'decider'     // Decision point (chose one branch)
  | 'fork'        // Parallel fork (all children ran)
  | 'selector'    // Selector (some children ran)
  | 'subflow'     // Subflow entry point
  | 'streaming'   // Streaming stage
  | 'root';       // Root node

// ============================================================================
// Tree Node Summary — Lightweight for LLM context
// ============================================================================

/**
 * Lightweight summary of a tree node.
 *
 * WHY: The LLM sees these first. Minimal tokens. Contains just enough
 * to decide which nodes to drill into.
 *
 * FORMAT EXAMPLE:
 *   [validate-input] Validate Input — Checks user input format and required fields
 *   [llm-call] LLM Call — Called Claude and received tool_use response
 *   [execute-tools] Execute Tools — Ran getUserDetails, returned user profile
 */
export interface TreeNodeSummary {
  /** Stable ID — the LLM uses this to call drillDown(id) */
  id: string;
  /** Human-readable name */
  name: string;
  /** Combined description (short — builder + narrative) */
  description: string;
  /** Whether children exist (LLM can explore deeper) */
  hasChildren: boolean;
  /** Number of children */
  childCount: number;
  /** Status indicator */
  status: 'success' | 'error' | 'skipped' | 'pending';
  /** Duration in ms */
  durationMs?: number;
}

// ============================================================================
// Tree Summary — Top-level overview for LLM
// ============================================================================

/**
 * Top-level execution summary.
 *
 * WHY: This is the FIRST thing the LLM sees. It provides:
 *   - List of all stages with IDs and descriptions (for navigation)
 *   - Aggregate stats (total duration, error count)
 *   - Quick indicators of what went wrong (error nodes)
 *
 * The LLM reads this, identifies interesting nodes, and calls drillDown(id).
 */
export interface TreeSummary {
  /** Flat list of all node summaries in execution order */
  nodes: TreeNodeSummary[];
  /** Total number of stages executed */
  totalStages: number;
  /** Total execution duration (ms) */
  totalDurationMs: number;
  /** Number of errors encountered */
  errorCount: number;
  /** IDs of nodes that had errors (quick lookup for LLM) */
  errorNodeIds: string[];
  /** IDs of the slowest nodes */
  slowNodeIds: string[];
  /** Human-readable text summary (for LLM to read directly) */
  textSummary: string;
}

// ============================================================================
// Drill Down Result — Full details for one node
// ============================================================================

/**
 * Full details for a single node, returned by drillDown(id).
 *
 * WHY: When the LLM wants to understand what happened at a specific stage,
 * it calls drillDown(id) and gets everything: reads, writes, metrics,
 * errors, narrative. This is the "zoom in" view.
 */
export interface DrillDownResult {
  /** The node being inspected */
  node: TreeNode;
  /** Breadcrumb path from root to this node */
  path: string[];
  /** Data reads performed by this stage */
  reads: DataOperation[];
  /** Data writes performed by this stage */
  writes: DataOperation[];
  /** Metrics for this stage */
  metrics: StageMetricsSummary;
  /** Errors that occurred in this stage */
  errors: ErrorDetail[];
  /** Sibling nodes (for context — what ran before/after) */
  siblings: TreeNodeSummary[];
  /** Parent node summary (for context) */
  parent?: TreeNodeSummary;
  /** Human-readable detail text (for LLM to read directly) */
  textDetail: string;
}

/**
 * A data read or write operation.
 */
export interface DataOperation {
  /** Operation type */
  type: 'read' | 'write';
  /** Scope path */
  path: string[];
  /** Key within the path */
  key: string;
  /** Summarized value (not raw — prevents token bloat) */
  valueSummary: string;
  /** Whether this was a set or update (writes only) */
  operation?: 'set' | 'update';
}

/**
 * Metric summary for a single stage.
 */
export interface StageMetricsSummary {
  /** Duration in ms */
  durationMs?: number;
  /** Number of scope reads */
  readCount: number;
  /** Number of scope writes */
  writeCount: number;
  /** Number of commits */
  commitCount: number;
  /** Number of errors */
  errorCount: number;
  /** Latency percentiles (if multiple invocations) */
  latencyPercentiles?: {
    min: number;
    max: number;
    p50: number;
    p95: number;
    p99: number;
    mean: number;
    count: number;
  };
}

/**
 * Detailed error information.
 */
export interface ErrorDetail {
  /** Error message */
  message: string;
  /** What operation was being performed */
  operation: string;
  /** Scope path involved (if applicable) */
  path?: string[];
  /** Key involved (if applicable) */
  key?: string;
  /** Timestamp */
  timestamp: number;
}

// ============================================================================
// Navigation Result — For getChildren / search
// ============================================================================

/**
 * Result of navigation operations (getChildren, search, etc.).
 */
export interface NavigationResult {
  /** The nodes found */
  nodes: TreeNodeSummary[];
  /** Total results (may be more than returned if paginated) */
  totalResults: number;
  /** Human-readable text for LLM */
  textResult: string;
}
